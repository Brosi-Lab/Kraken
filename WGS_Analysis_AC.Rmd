---
title: "WGS_analysis_AC"
author: "Anya Cutler"
date: "8/16/2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

suppressPackageStartupMessages(require(dplyr))
suppressPackageStartupMessages(require(stringr))
suppressPackageStartupMessages(require(reshape2))
suppressPackageStartupMessages(require(lme4))
suppressPackageStartupMessages(require(lmerTest))
suppressPackageStartupMessages(require(r2glmm))
suppressPackageStartupMessages(require(knitr))

```

## Table of Contents

## Table of Contents

* A. overview
* B. data import
* C. data prep + formatting
    1. Kraken Data Prep
    2. Combine Kraken and sample data for false negative analysis
    3. Remove Kraken reads below isolation threshhold 
    4. Combine simulation and empirical Kraken data
    5. Combine amplicon and empirical Kraken data
* D. data analysis
    1. Empirical Kraken false negative analysis - qualitative
    2. Empirical Kraken false negative analysis - quantitative
    3. Simulation Kraken false negative analysis - qualitative
    4. Simulation Kraken false negative analysis - quantitative
    5. Empirical vs. Simulation Kraken data - qualitative
    6. Empirical Kraken vs. Amplicon data - qualitative 

## A. overview
The basic idea behind this analysis is to largely repeat the analysis we did on the mixed-amplicon paper, especially given that the inputs (known / constructed pollen mixtures) are exactly the same; this `.Rmd` file is based directly on that analysis.

The pollen input samples were constructed to vary in three dimensions:

1. Question 1: species richness (1-9 species)
2. Question 2: rarity (actual proportion of grains this taxon has in a sample; from roughly half & half to < 1% of the rarer type)
3. Question 3: taxonomic relatedness (within genus to across broad clades in the seed plants)

The mixed-amplicon paper included two broad classes of analyses:
1. Qualitative matching: presence vs. absence of species in samples
  a. **false negative analysis** (binomial GLMMs, response = taxon presence in a sample). *I just realized that we can formally compare the qualitative performance of the amplicon-based approach to the WGS approach also with GLMMs*
2. Quantitative matching: proportion of reads in sample relative to proportion of pollen grains in mixture

In addition to repeating qualitative and quantitative analysis of the true positives/false negatives for the empirical and simulation WGS data, we will additionally do the following:
1. WGS vs. Amplicon data
    a. while it would be uninformative to assess presence / absence of false positive (since they are essentially ubiquitous in both the WGS and the amplicon-based data), we can actually analyze either counts or proportions (*maybe proportions better? i.e. with binomial errors*) of how many reads were false positives (vs. true positives) were in each sample
    b. this should be quite straightforward, i.e. binomial-errors mixed effects model with sample ID nested within sample type as random effects (*here I think we do not need to include 'species' as a random effect becuase the species mixtures are effectively covered by the sample type; and for each sample type we should have at least one sample from the amplicon data and from the WGS data*---essentially by setting up the random effects in this way we are running a paired-samples test); and the only fixed effect being the analysis method (amplicon vs. Kraken) 
    c. The more time-consuming bit will be to aggregate the counts---for each sample---of how many of the reads were true positives vs. false positives, merged into a single file for both the amplicon data and the Kraken data, with a column added for `sample.source` etc. *One key part of doing this will be to exclude samples from the amplicon data which do not have a corresponding Kraken data point*---we want all samples to be "paired".
    d. when we go to do the `dada2` vs. `QIIME` analysis, this false-positive analysis will be particularly key.
2. A comparison of the Kraken simulation vs. empirical results (probably qualitative? but we will have to analyze the simulations in the same way as the empirical data)  



## B. Data import
four data sets to import: 1) WGS Kraken empirical data; 2) Kraken simulation results; 3) sample metadata; 4) amplicon data
```{r data import}
krak = read.csv("kraken.csv")
mixes = read.csv("pollen-mixes-proportions.csv")
simkrak = read.csv("kraken_sim.csv")
amp_its_family = read.csv("Amplicon_ITS_Family.csv")
amp_its_genus = read.csv("Amplicon_ITS_Genus.csv")
amp_its_species = read.csv("Amplicon_ITS_Species.csv")
amp_rbc_family = read.csv("Amplicon_rbcL_Family.csv")
amp_rbc_genus = read.csv("Amplicon_rbcL_Genus.csv")
amp_rbc_species = read.csv("Amplicon_rbcL_Species.csv")

# 'mixes' comes in with some rows duplicated (because in the spreadsheet, each was assessed with both ITS2 and with rbcL); fix this here:
mixes = unique(mixes)

# 'krak' and 'simkrak' come with an extra numeric column at the beginning ('X'); delete
krak = krak[,-1]
simkrak = simkrak[,-1]

# change name of 'krak' & 'simkrak' identifier columns
# identifier column is called 'mix.id' but it is very different from the 'mix.ID' column in the 'mixes' data; we will ultimately want to join by 'mix.ID'
names(krak)[1] = "sample.id"
names(simkrak)[1] = "sample.id"

# check them out to make sure we're all good:
# View(krak)
# View(simkrak)
# View(mixes)
```

## C. data formatting / setup

* C.1 Kraken data prep
    + Jamie formatted these (25-Apr-2018) from the raw Kraken output to have the family / genus / species separated out into columns; see `Shotgun_data_prep.Rmd`
    + unlike the QIIME Illumina data, we do not need to do any aggregation of read counts as this was done automatically by Kraken (nice touch)
    + step 1: filter to include only matches at family / genus / species taxonomic resolutions (not anything coarser, and no intermediate clades)
    + step 2: create new columns for `mix.ID` that matches the column in the sample (`pollen-mixes-proportions.csv`) data
* C.2 Combine Kraken and sample data for false negative analysis
* C.3 Remove Kraken reads below isolation threshhold
* C.4 Combine simulation and empirical Kraken data
* C.5 Combine amplicon and empirical Kraken data

### C.1 Kraken data prep:

  1. filter by `tax.cat` column, including only species / genus / family levels
  2. create new column for `mix.ID` that matches the column in the sample (`pollen-mixes-proportions.csv`) data

```{r C.1: Kraken data prep}

# C.1.1: Kraken filtering (easy-peasy)

# first, filter out the reads to only include those at the family / genus / species levels
krak = filter(krak, tax == "F" | tax == "G" | tax == "S")

# for simkrak, results are already only order / family / genus / species matches
# thus, just exclude order-level matches
simkrak = filter(simkrak, tax != "O")

# C.1.2: create new column for `mix.ID` that matches the column in the sample (`pollen-mixes-proportions.csv`) data
# this is a bit more involved... a primary issue is that Emory and UGA used different naming conventions for the samples

# also create a new 'replicate.ID'; we will use this later to back-fill in the 'mixes' dataframe

## MIX.ID
## FIRST ONLY FOR 'KRAK' ('SIMKRAK' comes later)

# first, create the column; fill in temporarily the first 6 characters in the 'sample.id' column
krak$mix.ID = substr(krak$sample.id, 1, 6)

# move the new column to be second in order (not at the end where it's hard to see)
krak = krak[, c(1, ncol(krak), 3:ncol(krak)-1)]

#Want to remove the 6th character if mix.id does not contain the word "mix" or contains 2 dashes. Only want six characters if the mix number is double digits.

krak$mix.ID = ifelse(!grepl("mix", krak$mix.ID) | str_count(krak$mix.ID, pattern="-")==2, substr(krak$mix.ID, 1, 5), krak$mix.ID)

# second, replace underscores and dashes in the temp 'mix.ID' with periods so that they match the 'mixes' data
krak$mix.ID = gsub("-", ".", krak$mix.ID)
krak$mix.ID = gsub("_", ".", krak$mix.ID)

  # 2.1--fix capitalization for pecan ("c.ill"" should be "C.ill")
  krak$mix.ID = gsub("c.i", "C.i", krak$mix.ID)

# third, for the Emory mixes (different label), extract the mix from the text in the 'sample.id' column
# use 'str_extract' from the 'stringr' library (thank you tidyverse!) plus 'replace'
# (... took me quite a while to figure this out, dang regular expressions...)
# then do some cleanup

  # 4.1--extract strings and subset to only the relevant values  
  new.vals = str_extract(krak$sample.id, "mix_.*/")
  new.vals = new.vals[is.na(new.vals) == F]
  
  # 4.2--replace old vals with new.vals
  krak$mix.ID = replace(krak$mix.ID, krak$mix.ID=="repla", new.vals)
  
  # 4.3--cleanup
  krak$mix.ID = gsub("_", ".", krak$mix.ID)
  krak$mix.ID = gsub("/", "", krak$mix.ID)

# fourth, remove periods in between the text "mix" and the number 
krak$mix.ID = gsub("mix.", "mix", krak$mix.ID)

  
## 'REP.ID'
# noticed a weird quirk of the data: in the "B.pap" samples, the "1" at the end of the 'sample.id' is cut off. It may not really matter, but by making it consistent it will help make there be fewer levels / potential complications when appending onto the 'mixes' data
krak$sample.id = as.character(krak$sample.id)
indexy = str_sub(krak$sample.id, -1, -1)==0 # identifies which are missing the '1' at the end
# indexy = which(krak$mix.ID=="B.pap" & krak$rep.ID=="01.R")
krak$sample.id = replace(krak$sample.id, indexy, paste(krak$sample.id[indexy],"1", sep = ""))

# first, create the column; fill in the relevant characters from the 'sample.id' column
krak$rep.ID = substr(krak$sample.id, nchar(as.character(krak$sample.id))-7, nchar(as.character(krak$sample.id))-4) # 
# switch underscore to period
krak$rep.ID = gsub("_", ".", krak$rep.ID)

# move the new column to be second in order (not at the end where it's hard to see)
krak = krak[, c(1:2, ncol(krak), 4:ncol(krak)-1)]

## Sample number
sample_sep <- colsplit(krak$sample.id, "_", c("ID", "sample", "L", "R", "Num"))
krak$sample <- ifelse(startsWith(sample_sep$L,"S"), sample_sep$L, ifelse(startsWith(sample_sep$L,"1") | startsWith(sample_sep$L,"2"), sample_sep$R, sample_sep$sample))

##Create list of unique combinations of mix ID, sample number, and rep ID to properly merge kraken with mixes data at later point
krak_uniqueid <- data.frame(krak$mix.ID, krak$rep.ID, krak$sample)
krak_uniqueid <- unique.data.frame(krak_uniqueid)

# NOW FOR SIMKRAK
  
#Create a column for mix.id with the characters 6-10 of the sample id
simkrak$mix.ID = substr(simkrak$sample.id, 6, 10)

#Remove underscore for mixes with single digit
simkrak$mix.ID = gsub("_", "", simkrak$mix.ID)

#Move to second column as done in krak
simkrak = simkrak[, c(1, ncol(simkrak), 3:ncol(simkrak)-1)]
```

### C.2.1 combine Kraken & sample / mix data overview:
new aggregated datasheeet, based on sample metadata, but which matches sample data back to the Kraken data so we can run analyses about probability of matching (both qualitative and quantitative). In particular this is taking account of sample "replicates" (not true replicates at all, but forward vs. reverse reads); also different Illumina lanes in the Emory Genome Center data.

use 'mix.ID' as the variable to combine by...

```{r C.3 merge kraken data and metadata}


## Merge sample and replicate IDs with mixes data
krak_mixes <- merge(mixes,krak_uniqueid, by.x="mix.ID", by.y="krak.mix.ID")

#Create separate datasets for family, genus, and species level, both including and excluding false positives
truepos.krak.family =  merge(krak_mixes, filter(krak, tax == "F"), by = c("mix.ID", "family"), all.x=T)
truepos.krak.genus =  merge(krak_mixes, filter(krak, tax == "G"), by = c("mix.ID", "genus"), all.x=T)
truepos.krak.species =  merge(krak_mixes, filter(krak, tax == "S"), by = c("mix.ID", "species"), all.x=T)

all.krak.family =  merge(krak_mixes, filter(krak, tax == "F"), by = c("mix.ID", "family"), all.x = T, all.y = T)
all.krak.genus =  merge(krak_mixes, filter(krak, tax == "G"), by = c("mix.ID", "genus"), all.x = T, all.y = T)
all.krak.species =  merge(krak_mixes, filter(krak, tax == "S"), by = c("mix.ID", "species"), all.x = T, all.y = T)

#Repeat for SIMKRAK - Because there are no reps, need to subset mixes to the mixIDs contained in simkrak and merge data
sim_mixes <- subset(mixes, mixes$mix.ID %in% simkrak$mix.ID)

truepos.simkrak.family = merge(sim_mixes, filter(simkrak, tax == "F"), by = c("mix.ID", "family"), all.x = T)
truepos.simkrak.genus = merge(sim_mixes, filter(simkrak, tax == "G"), by = c("mix.ID", "genus"), all.x = T)
truepos.simkrak.species = merge(sim_mixes, filter(simkrak, tax == "S"), by = c("mix.ID", "species"), all.x = T)

all.simkrak.family = merge(sim_mixes, filter(simkrak, tax == "F"), by = c("mix.ID", "family"), all.x = T, all.y = T)
all.simkrak.genus = merge(sim_mixes, filter(simkrak, tax == "G"), by = c("mix.ID", "genus"), all.x = T, all.y=T)
all.simkrak.species = merge(sim_mixes, filter(simkrak, tax == "S"), by = c("mix.ID", "species"), all.x = T, all.y=T)
```


### C.2.2 match Kraken data to sample data, qualitatively & quantitatively

alternative approach based on `merge`; ultimately we want the 'mixes' dataset back (i.e. the input), with whether or not there was matching output.

**TO CONDUCT THIS COMPONENT WE FIRST NEED TO FILL IN THE SAMPLE REPLICATES INTO THE 'MIXES' TABLE--OTHERWISE WE WILL GET MORE MATCHES THAN WE HAVE ROWS IN 'MIXES'**

* use `merge` to do series of left-joins starting with the `mixes` dataset as the 'left' dataset and `krak` as the 'right' dataset
* three separate joins: family, genus, and species
    + each dataset can then be used to run analyses

```{r match Illumina to sample data}


#Create quantitative variable by simply dividing the percentage hits (perc.hit) by 100
krak.family$quant.family = krak.family$perc.hit/100
krak.genus$quant.genus = krak.genus$perc.hit/100
krak.species$quant.species = krak.species$perc.hit/100

#For taxa that were not detected, NAs are currently present. Need to change this to 0 for quantitative variable before running analysis.
krak.family$quant.family = ifelse(is.na(krak.family$quant.family), 0, krak.family$quant.family)
krak.genus$quant.genus = ifelse(is.na(krak.genus$quant.genus), 0, krak.genus$quant.genus)
krak.species$quant.species = ifelse(is.na(krak.species$quant.species), 0, krak.species$quant.species)

#Create qualitative variable based on quantitative variable
krak.family$qual.family = ifelse(krak.family$quant.family > 0, 1, 0)
krak.genus$qual.genus = ifelse(krak.genus$quant.genus > 0, 1, 0)
krak.species$qual.species = ifelse(krak.species$quant.species > 0, 1, 0)

#Merge sample and rep ID
krak.family$samp_rep = paste(krak.family$krak.sample, "_", krak.family$krak.rep.ID)
krak.genus$samp_rep = paste(krak.genus$krak.sample, "_", krak.genus$krak.rep.ID)
krak.species$samp_rep = paste(krak.species$krak.sample, "_", krak.species$krak.rep.ID)

##Repeat for SIMKRAK
simkrak.family$quant.family = simkrak.family$perc.hit/100
simkrak.genus$quant.genus = simkrak.genus$perc.hit/100
simkrak.species$quant.species = simkrak.species$perc.hit/100

krak.family$quant.family = ifelse(is.na(krak.family$quant.family), 0, krak.family$quant.family)
krak.genus$quant.genus = ifelse(is.na(krak.genus$quant.genus), 0, krak.genus$quant.genus)
krak.species$quant.species = ifelse(is.na(krak.species$quant.species), 0, krak.species$quant.species)
```

### C.3 filter data to remove reads below the isolation / PCR negative control thresholds

**I THINK WE ACTUALLY WANT TO DO THIS ONLY AFTER WE DO THE INITIAL JOIN WITH THE MIXES DATA, BECAUSE THIS COULD REMOVE SOME OF THE REPLICATES FROM THE DATA AND WE WANT TO REGISTER THAT THEY DIDN'T HAVE ANY HITS**

1. remove reads below the isolation / PCR negative control thresholds
      a) this step is only for the empirical data (unnecessary for the simulated data)
      b) ideally, would base these on negative controls **for a given Illumina run** (two separate runs here, at UGA and Emory Genome center; we will need to keep those separate); but **unfortunately** there do not appear to be negative controls for the Emory Genome Center data; I will use the UGA thresholds for all the data
      c) this entails removing rows with k-mer counts below the threshold
      d) in the Illumina QIIME amplicon data, we did this separately for (entire) taxa below the threshold level, and for reads, because of the way that the data were formatted in a taxon-by-sample matrix; the Kraken output is already formatted in a way that is closer to `tidy` so we only need to do this step once here.
2. remove negative control rows (once the above is completed)

```{r C.2 remove reads below contamination threshold}


# # establish threshold (identify the maximum across all rows of negative controls):
maxy = max(krak$hits[krak$mix.ID=="negat"])
# 
# # set up index of rows to remove (with 'hits' <= maxy)
indexy_family = which(krak.family$hits <= maxy)
indexy_genus = which(krak.genus$hits <= maxy)
indexy_species = which(krak.species$hits <= maxy)
# 
# No rows with thresshold below maxy

```

### C.4 Combine simulation and Kraken data
*Need to figure out best way to do this analysis*

### C.5 Combine WGS and amplicon data
We need to combine the WGS with amplicon data by creating a dataframe showing the number of true positive and the number of false positive reads by source, mix ID, and sample ID.

```{r C.5 WGS and amplicon aggregation}


#Create list of amplicon data frames
amp_data <- list(amp_its_family, amp_its_genus, amp_its_species, amp_rbc_family, amp_rbc_genus, amp_rbc_species)

#Apply function to list
amp_convert <- lapply(amp_data, function(x){
  #convert first column name to "taxa"
  names(x)[1] <- "taxa"
  #convert from wide to long format
  x <- melt(x, id.vars="taxa", value.name="hits")
  #separate mix ID and sample ID
  x[,4:5] <- colsplit(x$variable, "_", c("mix.ID", "sample"))
  #remove variable "id"
  x <- x[,-2]
})

#Extract data frames from list
amp_its_family <- as.data.frame(amp_convert[1])
amp_its_genus <- as.data.frame(amp_convert[2])
amp_its_species <- as.data.frame(amp_convert[3])
amp_rbc_family <- as.data.frame(amp_convert[4])
amp_rbc_genus <- as.data.frame(amp_convert[5])
amp_rbc_species <- as.data.frame(amp_convert[6])


#Merge with mixes data by mixID and sampleID
amp_its_family_mix <- merge(amp_its_family, mixes, by.x=c("mix.ID", "taxa"), by.y=c("mix.ID", "family"), all.x=T)
amp_its_genus_mix <- merge(amp_its_genus, mixes, by.x=c("mix.ID", "taxa"), by.y=c("mix.ID", "genus"), all.x=T)
amp_its_species_mix <- merge(amp_its_species, mixes, by.x=c("mix.ID", "taxa"), by.y=c("mix.ID", "species"), all.x=T)
amp_rbc_family_mix <- merge(amp_rbc_family, mixes, by.x=c("mix.ID", "taxa"), by.y=c("mix.ID", "family"), all.x=T)
amp_rbc_genus_mix <- merge(amp_rbc_genus, mixes, by.x=c("mix.ID", "taxa"), by.y=c("mix.ID", "genus"), all.x=T)
amp_rbc_species_mix <- merge(amp_rbc_species, mixes, by.x=c("mix.ID", "taxa"), by.y=c("mix.ID", "species"), all.x=T)

#Rows with mixes variables that are "NA" are false positive taxa. Create a data frame that indicates if row is true positive or false positive
amp_its_family_mix$type <- ifelse(is.na(amp_its_family_mix$question.1), "false_pos", "true_pos")
amp_its_genus_mix$type <- ifelse(is.na(amp_its_genus_mix$question.1), "false_pos", "true_pos")
amp_its_species_mix$type <- ifelse(is.na(amp_its_species_mix$question.1), "false_pos", "true_pos")
amp_rbc_family_mix$type <- ifelse(is.na(amp_rbc_family_mix$question.1), "false_pos", "true_pos")
amp_rbc_genus_mix$type <- ifelse(is.na(amp_rbc_genus_mix$question.1), "false_pos", "true_pos")
amp_rbc_species_mix$type <- ifelse(is.na(amp_rbc_species_mix$question.1), "false_pos", "true_pos")

#New list of mixed datasets
amp_mixed <- list(amp_its_family_mix, amp_its_genus_mix, amp_its_species_mix, amp_rbc_family_mix, amp_rbc_genus_mix, amp_rbc_species_mix)

#Apply function to list
amp_summed <- lapply(amp_mixed, function(x){
  #summarize number of hits by mix.ID, sample, and type
  x <- x %>%
          select(mix.ID, taxa, hits, sample, type) %>%
          group_by(mix.ID, sample, type) %>%
          summarize(total_hits = sum(hits))
  #Convert to wide format with one column for true positive hits and one column for false positive hits
  #x <- reshape(x, idvar="sample", timevar="type", direction="wide")
})

amp_its_family_summ <- as.data.frame(amp_summed[1])
amp_its_genus_summ <- as.data.frame(amp_summed[2])
amp_its_species_summ <- as.data.frame(amp_summed[3])
amp_rbc_family_summ <- as.data.frame(amp_summed[4])
amp_rbc_genus_summ <- as.data.frame(amp_summed[5])
amp_rbc_species_summ <- as.data.frame(amp_summed[6])


#Add "A" to beginning of sample ID - couldn't get this to work in the lapply function
amp_its_family_summ$sample <- paste("A_", amp_its_family_summ$sample, sep="")
amp_its_genus_summ$sample <- paste("A_", amp_its_genus_summ$sample, sep="")
amp_its_species_summ$sample <- paste("A_", amp_its_species_summ$sample, sep="")
amp_rbc_family_summ$sample <- paste("A_", amp_rbc_family_summ$sample, sep="")
amp_rbc_genus_summ$sample <- paste("A_", amp_rbc_genus_summ$sample, sep="")
amp_rbc_species_summ$sample <- paste("A_", amp_rbc_species_summ$sample, sep="")

#Convert to wide format with one column for true positive hits and one column for false positive hits - couldn't get this to work in the lapply function
amp_its_family_reshape <- reshape(amp_its_family_summ, idvar=c("sample", "mix.ID"), timevar="type", direction="wide")
amp_its_genus_reshape <- reshape(amp_its_genus_summ, idvar=c("sample", "mix.ID"), timevar="type", direction="wide")
amp_its_species_reshape <- reshape(amp_its_species_summ, idvar=c("sample", "mix.ID"), timevar="type", direction="wide")
amp_rbc_family_reshape <- reshape(amp_rbc_family_summ, idvar=c("sample", "mix.ID"), timevar="type", direction="wide")
amp_rbc_genus_reshape <- reshape(amp_rbc_genus_summ, idvar=c("sample", "mix.ID"), timevar="type", direction="wide")
amp_rbc_species_reshape <- reshape(amp_rbc_species_summ, idvar=c("sample", "mix.ID"), timevar="type", direction="wide")

#Rename variables to "true_pos" and "false_pos"
amp_its_family_reshape <- rename(amp_its_family_reshape, false_pos = total_hits.false_pos, true_pos = total_hits.true_pos)
amp_its_genus_reshape <- rename(amp_its_genus_reshape, false_pos = total_hits.false_pos, true_pos = total_hits.true_pos)
amp_its_species_reshape <- rename(amp_its_species_reshape, false_pos = total_hits.false_pos, true_pos = total_hits.true_pos)
amp_rbc_family_reshape <- rename(amp_rbc_family_reshape, false_pos = total_hits.false_pos, true_pos = total_hits.true_pos)
amp_rbc_genus_reshape <- rename(amp_rbc_genus_reshape, false_pos = total_hits.false_pos, true_pos = total_hits.true_pos)
amp_rbc_species_reshape <- rename(amp_rbc_species_reshape, false_pos = total_hits.false_pos, true_pos = total_hits.true_pos)

#Repeat for Kraken data

#Merge Kraken and Amplicon data


```

## D.1 Analysis

Repeat analysis from mixed amplicon analysis. For consistency, take out Zea and format data tables to have the same name as those in the mixed amplicon analysis. 

```{r D.1 analysis setup}

#Take out Zea
krak.family = filter(krak.family, genus.x!= "Zea") 
krak.genus = filter(krak.genus, genus!="Zea")
krak.species = filter(krak.species, genus.x!="Zea")

taxon = c("species", "genus", "family")


# first set up a table for the results:
# I will set this up with 18 entries
results.table = data.frame(question = rep(NA,18), taxon  = rep(NA,18), data.subset  = rep(NA,18), model.name = rep(NA,18), p.val  = rep(1.000001,18), n  = rep(9999,18), warning.msg = rep(NA,18))

# keep track of which row of the table to record in:
tracker = 1

# # EXAMPLE FORMULA
# Q1.species.rbcL.sub = glmer(qual.species.rbcL ~ spp.rich + (1|mix.ID/rep.ID) + (1|species), family = binomial, data = data.species, control = glmerControl(optimizer="bobyqa"))
# summary(Q1.species.rbcL.sub)

# basis of subsetting:
# sub = filter(data, question.1 ==1 | question.2 ==1 | question.3==1)
datasubset = c("sub", "all") # whether we are using the designated subset of data designed for the question, or all data

# response variables relating to each of the three questions (column names in data)
question = c("spp.rich", "relatedness", "pollen.grain.proportion")

for(q in 1:3) { # 'question': response variables for Q1 / Q2 / Q3
    for(k in 1:3){ # 'taxon': species, genus, family
      for(l in 1:2) { # 'datasubset': sub or all
        # first, name the analysis:
        namer = paste("Krak.Q", q, ".", taxon[k], ".", datasubset[l], sep = "")
        # # 1.5, print name of which model was evaluated
        # print("**************************************************")
        # print(paste("*********************     ", namer, "     *********************"))
        # print(paste("question q = ", q, "; taxon k = ", k, "; datasubset l = ", l))
        # print("**************************************************")
        # second, set which taxonomic data to use:
        data.to.use = paste("krak.", taxon[k], sep = "")
        # third, set up the data subset (may or may not use)
        subster = paste("data.sub = filter(", data.to.use, ", question.1 == ", q, " | question.2 == ", q, " | question.3 == ",q, ")", sep = "")
        eval(parse(text = subster)) # probably not the most efficient thing ever... 
        # fourth, set whether or not data subset is used (vs. all data)
        if(datasubset[l]=="sub") {data.to.use = "data.sub"} # i.e., doesn't change if all data are to be            used
        # fifth, set up mixed-effects model: 
        mixed = paste(namer, " = suppressWarnings(glmer(qual.", taxon[k],
          " ~ ",  question[q], " + (1|mix.ID/samp_rep) + (1|", taxon[k], "), family = binomial, 
          data = ", data.to.use, ", control = glmerControl(optimizer=\"bobyqa\")))", sep = "")
        # sixth, evaluate the mixed-effects model
        eval(parse(text = mixed))
            # # eighth, print summary of model [SKIP FOR NOW]
            # summarizer = paste("print(summary(", namer, "))", sep = "")
            # eval(parse(text = summarizer)) # print summary of the mixed-effects model
        
        ## extract p-value
        # example: coef(summary(Q3.genus.ITS.all))[2,4]
        pvaller = paste("pval <- coef(summary(", namer, "))[2,4]", sep = "")
        eval(parse(text = pvaller))
        
        # extract convergence failures
        converger = paste(namer, "@optinfo$conv$lme4$code", sep = "")
        converg = eval(parse(text = converger))
        converg.return = ifelse(length(converg)==1, "ERROR!!", "")
        
        # record results in table
        results.table[tracker,1] = question[q]
        results.table[tracker,2] = taxon[k]
        results.table[tracker,3] = datasubset[l]
        results.table[tracker,4] = namer
        results.table[tracker,5] = pval
        results.table[tracker,6] = nrow(eval(parse(text = data.to.use)))
        results.table[tracker,7] = converg.return
        
        # advance tracker
        tracker = tracker + 1
      }
    }
  }


```

*note: warning messages suppressed for neatness. Any model with convergence errors is noted in the table below*

## RESULTS: mixed-effects models for qualitative matching

**REMEMBER: THESE DATA DO NOT INCLUDE ZEA**

**TAKE-HOME MESSAGE:** None of the factors we examined is a statistically important driver of qualitative matching. Just two models without problems / errors were statistically significant: 

* `Q2.genus.rbcL.all`---rarity / proportion of pollen grains, matched at the genus level, for *rbcL* and including all data (not just the subset of data focused on rarity)
* `Q3.genus.rbcL.all`---relatedness, matched at the genus level, for *rbcL* and including all data (not just the subset of data focused on relatedness)

It is worth noting that the models that used all the data included the single-species data as well as the mixes. I think that we should largely focus on the **subset** models, as they were designed with the questions in mind.

More detail on any particular model can be obtained by typing "summary(model)" in the console, and replacing 'model' with the model name from the 'model.name' column in the results table below.

```{R display results}
# display results table
# note that the 'kable' function is part of the 'knitr' package, which I required at the very top of this document. 
kable(results.table)
```

##Quantitative results

```{R quantitative matching}

# ultimately want 3 analyses: {species, genus, and family}
# species
quant.species = lmer(quant.species ~ pollen.grain.proportion + (1|mix.ID) + (1|species), data = krak.species)

# genus
quant.genus = lmer(quant.genus ~ pollen.grain.proportion + (1|mix.ID) + (1|genus), data = krak.genus)

#family
quant.family = lmer(quant.family ~ pollen.grain.proportion + (1|mix.ID) + (1|family), data = krak.family)


#=========================================
# r-squared calculation at the family level
r2.family = r2beta(quant.family)

# r-squared calculation at the genus level
r2.genus = r2beta(quant.genus)

# r-squared calculation at the species level
r2.species = r2beta(quant.species)

#Merge the slope ("Estimate"), p-value ("Pr...t..") from the mixed models with the r-squared value for each test

coefs_quant.family <- cbind((data.frame(coef(summary(quant.family)))["pollen.grain.proportion",c("Estimate","Pr...t..")]), r2.family[2,6]) 

coefs_quant.genus <- cbind((data.frame(coef(summary(quant.genus)))["pollen.grain.proportion",c("Estimate","Pr...t..")]), r2.genus[2,6]) 

coefs_quant.species <- cbind((data.frame(coef(summary(quant.species)))["pollen.grain.proportion",c("Estimate","Pr...t..")]), r2.species[2,6]) 

#Rename row names and column names 
row.names(coefs_quant.family) = "Family"
row.names(coefs_quant.genus) = "Genus"
row.names(coefs_quant.species) = "Species"

colnames(coefs_quant.family) = c("Slope", "p-value", "R2")
colnames(coefs_quant.genus) = c("Slope", "p-value", "R2")
colnames(coefs_quant.species) = c("Slope", "p-value", "R2")

#Merge summary of coefficients into one dataset
coefs_summ <- rbind(coefs_quant.family, coefs_quant.genus, coefs_quant.species)

#Display table of summarized coefficients
kable(coefs_summ)

```

##Comparison of amplicon and shotgun results: Qualitative data

```{r comparison shotgun and amplicon - qual}

#Import qualitative results from amplicon analysis

load("/Users/ajcutle/Kraken/qual_amplicon_results.RData")

#Create data frame to hold ITS results: 3 questions x 2 datasets x 2 taxonomic levels x 1 markers = 12 rows
ITS_comp_AIC= data.frame(question = rep(NA,12), taxon  = rep(NA,12), data.subset  = rep(NA,12), Krak_AIC = rep(NA,12), Amp_AIC  = rep(NA,12))
rbcL_comp_AIC= data.frame(question = rep(NA,12), taxon  = rep(NA,12), data.subset  = rep(NA,12), Krak_AIC = rep(NA,12), Amp_AIC  = rep(NA,12))

its_tracker = 1
rbc_tracker = 1

#Loop for ITS table
for(q in 1:3) { # 'question': response variables for Q1 / Q2 / Q3
    for(k in 1:2){ # 'taxon': species, genus (Family not included in amplicon analysis)
      for(l in 1:2) { # 'datasubset': sub or all
        # first, name the comparison:
        namer = paste("Q", q, ".", taxon[k], ".", datasubset[l], sep = "")
        # second, set which taxonomic data to use:
        krak_data.to.use = paste("Krak.Q", q, ".", taxon[k], ".", datasubset[l], sep = "")
        amp_data.to.use = paste("Q", q, ".", taxon[k], ".", "ITS.", datasubset[l], sep = "")
       
        
        ## extract Kraken AIC 
        # example: extractAIC(Krak.Q1.genus.all)
        Krak_AICer = paste("krakaic <- extractAIC(",krak_data.to.use,")[2]", sep = "")
         eval(parse(text = Krak_AICer))
         
        ## extract Amplicon AIC 
        # example: extractAIC(Q1.genus.ITS.all)
        Amp_AICer = paste("ampaic <- extractAIC(",amp_data.to.use,")[2]", sep = "")
        eval(parse(text = Amp_AICer))
        
        # record results in table
        ITS_comp_AIC[its_tracker,1] = question[q]
        ITS_comp_AIC[its_tracker,2] = taxon[k]
        ITS_comp_AIC[its_tracker,3] = datasubset[l]
        ITS_comp_AIC[its_tracker,4] = krakaic
        ITS_comp_AIC[its_tracker,5] = ampaic
        
        # advance tracker
        its_tracker = its_tracker + 1
      }
    }
  }

kable(ITS_comp_AIC)

#Repeat for rbcL

for(q in 1:3) { # 'question': response variables for Q1 / Q2 / Q3
    for(k in 1:2){ # 'taxon': species, genus (Family not included in amplicon analysis)
      for(l in 1:2) { # 'datasubset': sub or all
        # first, name the comparison:
        namer = paste("Q", q, ".", taxon[k], ".", datasubset[l], sep = "")
        # second, set which taxonomic data to use:
        krak_data.to.use = paste("Krak.Q", q, ".", taxon[k], ".", datasubset[l], sep = "")
        amp_data.to.use = paste("Q", q, ".", taxon[k], ".", "rbcL.", datasubset[l], sep = "")
       
        
        ## extract Kraken AIC 
        # example: extractAIC(Krak.Q1.genus.all)
        Krak_AICer = paste("krakaic <- extractAIC(",krak_data.to.use,")[2]", sep = "")
         eval(parse(text = Krak_AICer))
         
        ## extract Amplicon AIC 
        # example: extractAIC(Q1.genus.ITS.all)
        Amp_AICer = paste("ampaic <- extractAIC(",amp_data.to.use,")[2]", sep = "")
        eval(parse(text = Amp_AICer))
        
        # record results in table
        rbcL_comp_AIC[rbc_tracker,1] = question[q]
        rbcL_comp_AIC[rbc_tracker,2] = taxon[k]
        rbcL_comp_AIC[rbc_tracker,3] = datasubset[l]
        rbcL_comp_AIC[rbc_tracker,4] = krakaic
        rbcL_comp_AIC[rbc_tracker,5] = ampaic
        
        # advance tracker
        rbc_tracker = rbc_tracker + 1
      }
    }
  }

kable(rbcL_comp_AIC)
```


##Comparison of amplicon and shotgun results: Quantitative data
```{r comparison shotgun and amplicon - quant}

#Import quantitative results from amplicon analysis

load("/Users/ajcutle/Kraken/quant_amplicon_results.RData")

#Create data frame to hold ITS results: 3 taxon levels x 1 marker = 3 rows
ITS_comp_AIC= data.frame(taxon  = rep(NA,3), Krak_AIC = rep(NA,3), Amp_AIC  = rep(NA,3))
rbcL_comp_AIC= data.frame(taxon  = rep(NA,3), Krak_AIC = rep(NA,3), Amp_AIC  = rep(NA,3))

its_tracker = 1
rbc_tracker = 1

#Loop for ITS table
for(k in 1:3) { # 'taxon': species, genus, family
        # first, name the comparison:
        namer = taxon[k]
        # second, set which taxonomic data to use:
        krak_data.to.use = paste("quant.", taxon[k], sep = "")
        amp_data.to.use = paste("quant.ITS.", taxon[k], sep = "")
       
        
        ## extract Kraken AIC 
        # example: extractAIC(Krak.Q1.genus.all)
        Krak_AICer = paste("krakaic <- extractAIC(",krak_data.to.use,")[2]", sep = "")
         eval(parse(text = Krak_AICer))
         
        ## extract Amplicon AIC 
        # example: extractAIC(Q1.genus.ITS.all)
        Amp_AICer = paste("ampaic <- extractAIC(",amp_data.to.use,")[2]", sep = "")
        eval(parse(text = Amp_AICer))
        
        # record results in table
        ITS_comp_AIC[its_tracker,1] = taxon[k]
        ITS_comp_AIC[its_tracker,2] = krakaic
        ITS_comp_AIC[its_tracker,3] = ampaic
        
        # advance tracker
        its_tracker = its_tracker + 1
      }

kable(ITS_comp_AIC)

#Repeat for rbcL

for(k in 1:3) { # 'taxon': species, genus, family
        # first, name the comparison:
        namer = taxon[k]
        # second, set which taxonomic data to use:
        krak_data.to.use = paste("quant.", taxon[k], sep = "")
        amp_data.to.use = paste("quant.rbcL.", taxon[k], sep = "")
       
        
        ## extract Kraken AIC 
        # example: extractAIC(Krak.Q1.genus.all)
        Krak_AICer = paste("krakaic <- extractAIC(",krak_data.to.use,")[2]", sep = "")
         eval(parse(text = Krak_AICer))
         
        ## extract Amplicon AIC 
        # example: extractAIC(Q1.genus.ITS.all)
        Amp_AICer = paste("ampaic <- extractAIC(",amp_data.to.use,")[2]", sep = "")
        eval(parse(text = Amp_AICer))
        
        # record results in table
        rbcL_comp_AIC[rbc_tracker,1] = taxon[k]
        rbcL_comp_AIC[rbc_tracker,2] = krakaic
        rbcL_comp_AIC[rbc_tracker,3] = ampaic
        
        
        # advance tracker
        rbc_tracker = rbc_tracker + 1
      }

kable(rbcL_comp_AIC)

```
